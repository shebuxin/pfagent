Question,Answer
"Code: import andes
import os

script_dir = os.getcwd()
case = os.path.join(script_dir, 'ieee39_base.xlsx')

ssa = andes.load(case,
                setup=False,
                no_output=True,
                default_config=False)

# setup the case and call the power flow calculation
ssa.setup()
ssa.PFlow.run()

print(""PV Bus Active Power"", ssa.PV.p.v)
print(""PV Bus Reactive Power"", ssa.PV.q.v)
print(""Slack Bus Active Power"", ssa.Slack.p.v)
print(""Slack Bus Reactive Power"", ssa.Slack.q.v)
print(""Bus Voltages"", ssa.Bus.v.v)
print(""Bus Angles"", ssa.Bus.a.v)

print(""Phase Angle of the From Bus"", ssa.Line.a1.e)
print(""Shape of ssa.Line.a1.e:"", ssa.Line.a1.e.shape)
print(""ssa.Line.a1.e via get():"", ssa.Line.get(src='a1', idx= ssa.Line.idx.v, attr='e'))
print(""Phase Angle of the To Bus"", ssa.Line.a2.e)


# Run a power-flow simulation and display key results for the PV buses, Slack bus, system buses, and transmission lines.
                Code Output: STDERR:
error: file ""/home/chen541/ANDES_Data/PowerFlow_Specific/ieee39_base.xlsx"" does not exist.
No valid case found.
Traceback (most recent call last):
  File ""/home/chen541/ANDES_Data/PowerFlow_Specific/code_examples/powerflow-ex1.py"", line 13, in <module>
    ssa.setup()
    ^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'setup'

ERROR conda.cli.main_run:execute(125): `conda run python code_examples/powerflow-ex1.py` failed. (See above for error)

Return Code: 1","The snippet you provided is intended to

 1. import the ANDES power‐flow library  
 2. load an IEEE-39 bus test case from an Excel file  
 3. run a steady‐state power‐flow  
 4. print out  
    – each PV‐bus’s P and Q injections  
    – the slack bus’s P and Q injections  
    – all bus voltages and angles  
    – the “from” and “to” phase‐angles on each transmission line  

However, when you ran it you immediately got:

  • “error: file …/ieee39_base.xlsx does not exist. No valid case found.”  
  • ANDES returns None for `ssa`  
  • your call to `ssa.setup()` raises `AttributeError: 'NoneType' object has no attribute 'setup'`  

Because the Excel case file was not found, ANDES never loaded a model and the power‐flow never executed. No numerical results (bus P, Q, voltages, angles, or line angles) were produced.  

For an electrical engineer’s workflow, you should first make sure the path to your bus‐data file is correct and reachable by ANDES (or use an absolute path). Once the case loads successfully and `ssa` is not None, re-running will yield:

  – PV‐bus active/reactive power injections  
  – Slack‐bus active/reactive power injection  
  – All bus voltage magnitudes and angle profiles  
  – Transmission line “from” and “to” end phase‐angles  

Those outputs would then let you inspect generation dispatch, voltage profile, and angle differences across lines for the IEEE-39–bus system."
"Code: import andes
import os

script_dir = os.getcwd()
case = os.path.join(script_dir, 'ieee39_base.xlsx')

ssa = andes.load(case,
                setup=True,
                no_output=True,
                default_config=False)

# call the power flow calculation
ssa.PFlow.run()

print(""PV Bus Active Power"", ssa.PV.p.v)
print(""PV Bus Reactive Power"", ssa.PV.q.v)
print(""Slack Bus Active Power"", ssa.Slack.p.v)
print(""Slack Bus Reactive Power"", ssa.Slack.q.v)
print(""Bus Voltages"", ssa.Bus.v.v)
print(""Bus Angles"", ssa.Bus.a.v)


# Load the IEEE 39-bus case, run a power-flow simulation, and display key results for the PV buses, Slack bus, and all system buses.
                Code Output: STDERR:
error: file ""/home/chen541/ANDES_Data/PowerFlow_Specific/ieee39_base.xlsx"" does not exist.
No valid case found.
Traceback (most recent call last):
  File ""/home/chen541/ANDES_Data/PowerFlow_Specific/code_examples/powerflow-ex2.py"", line 13, in <module>
    ssa.PFlow.run()
    ^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'PFlow'

ERROR conda.cli.main_run:execute(125): `conda run python code_examples/powerflow-ex2.py` failed. (See above for error)

Return Code: 1","The supplied script is intended to

  1. Load the standard IEEE-39 (“New England”) base case from an Excel file (“ieee39_base.xlsx”) into the ANDES power‐flow engine  
  2. Run a full AC power‐flow  
  3. Print out  
     – Active/Reactive power at all PV buses  
     – Active/Reactive power at the Slack bus  
     – Voltage magnitudes and angles at every bus  

However, in this run the script fails immediately at step 1 because ANDES cannot find the Excel file. Specifically:

  • ANDES reports  
      error: file ""/home/chen541/ANDES_Data/PowerFlow_Specific/ieee39_base.xlsx"" does not exist.  
      No valid case found.

  • As a result, `andes.load(…)` returns None, so `ssa` is None  
  • The next line, `ssa.PFlow.run()`, raises  
      AttributeError: 'NoneType' object has no attribute 'PFlow'  

No power-flow solution is produced and no bus or generator quantities are computed.  

Recommended corrective actions for an electrical-engineering workflow:  
  • Verify that “ieee39_base.xlsx” is present in the working directory (or adjust the path)  
  • Confirm that ANDES can read the spreadsheet (correct sheet names, columns, units)  
  • Once the case loads properly, re‐running the script will yield:  
     – PV bus outputs (P and Q in MW and MVAr)  
     – Slack bus generation (P and Q)  
     – All bus voltages (per‐unit) and angles (degrees)  

These results are the standard deliverables of an AC power‐flow on the 39-bus test system."
"Code: import andes

ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=False,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

# Add new load
ssa.add(model=""PQ"", param_dict=dict(bus=2, 
                                    idx=""PQ_20"", 
                                    p0=0.5, 
                                    q0=0.2
                                    ))

# Add new generator
ssa.add(model=""PV"", param_dict=dict(bus=15, 
                                    idx='15', 
                                    p0=0.5, 
                                    q0=0.2,
                                    pmax=5,
                                    pmin=0,
                                    qmax=2,
                                    qmin=-2,
                                    v0=1.0,
                                    ))

ssa.setup()
ssa.PFlow.run()


# Load the IEEE 39-bus case, add a new load and a new PV generator, then set up and run a power-flow simulation.
                Code Output: No Output Generated","The script does the following (no printed output, but all results are stored internally in `ssa.PFlow.results`):

1. Load the IEEE 39-bus test system  
   • Uses `andes.get_case('ieee39/ieee39.xlsx')` with  
       – `setup=False` (delays Y-bus and model‐object creation until `ssa.setup()`)  
       – `no_output=True` (suppresses any automatic printouts)  
       – `default_config=False` (you are in full control of which models get instantiated)

2. Add a new PQ‐load at bus 2  
   • Real power P₀ = 0.5 pu, reactive power Q₀ = 0.2 pu  
   • Internal index/key “PQ_20”

3. Add a new PV generator at bus 15  
   • Initial setpoints P₀ = 0.5 pu, Q₀ = 0.2 pu, V₀ = 1.0 pu  
   • Operating limits: 0 ≤ P ≤ 5 pu, –2 ≤ Q ≤ 2 pu  

4. Build and run a Newton–Raphson power‐flow  
   • `ssa.setup()` assembles the network admittance matrix, instantiates bus, branch, machine objects  
   • `ssa.PFlow.run()` solves for bus voltages and generator reactive dispatch

Key points for an electrical engineer:  
– The PQ‐load injection at bus 2 and the PV‐unit injection at bus 15 will alter the operating point—check the voltage profile and line flows, particularly around those buses.  
– Generator Q‐output at bus 15 will be regulated within [–2, 2] pu to hold V = 1.0 pu.  
– All numerical results (bus voltages magnitudes/angles, branch flows, machine Q outputs, power mismatches) are available in Python via  
   • `ssa.PFlow.results.Vm` (bus voltages),  
   • `ssa.PFlow.results.Va` (bus angles),  
   • `ssa.PFlow.results.Pg`, `Qg` (generator injections),  
   • `ssa.PFlow.results.Pf`, `Qf` / `Pt`, `Qt` (branch flows).  
– No convergence messages were printed because of `no_output=True`; you can check `ssa.PFlow.success` (Boolean) or `ssa.PFlow.summary()` to verify convergence and residual levels."
"Code: import andes
import numpy as np

ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=False,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

ssa.setup()

# Scale up (perturb) the voltage states of both p0 and q0 by 10%. 
ssa.PQ.set(
            src='p0', 
            idx= ssa.PQ.idx.v, 
            attr='v',
            value=1.1 * ssa.PQ.p0.v
        )

ssa.PQ.set(
            src='q0', 
            idx= ssa.PQ.idx.v, 
            attr='v',
            value=1.1 * ssa.PQ.q0.v
        )

ssa.PFlow.run()

print(""PQ.p0.v After Scaling:"", ssa.PQ.p0.v)
print(""PQ.q0.v After Scaling:"", ssa.PQ.q0.v)


# Load the IEEE 39-bus case, scale the active and reactive power demands of all PQ loads by 10%, then run a power-flow simulation and display the updated values.

                Code Output: STDOUT:
PQ.p0.v After Scaling: [6.6    4.95   2.5718 5.742  1.32   3.52   3.6234 1.738  7.48   3.014
 2.7225 3.3946 2.464  1.529  3.091  2.266  3.1185 0.88   4.4   ]
PQ.q0.v After Scaling: [ 2.75    2.024   9.24    1.936   0.33    1.683   3.553   0.33    1.133
  1.265   0.9306 -1.0142  0.5192  0.187   0.8305  0.3036  1.3959  0.44
  2.75  ]","Here’s what the snippet does and what the printed arrays mean from an EE‐perspective:

1. It loads the IEEE 39-bus test case into ANDES, but with setup deferred (setup=False), so you have to call ssa.setup() before any simulation.  
2. It takes the default active-power demand vector p0 and reactive-power demand vector q0 at all PQ buses (there are 19 PQ buses in the 39-bus case) and multiplies each element by 1.1 (i.e. +10% load increase).  
3. It runs a power-flow (PFlow) solve with these bumped loads.  
4. It then prints out the new p0.v and q0.v vectors.

The two output lines are simply those 19-element vectors of P and Q, each entry in per-unit on the system base (usually MW and MVAr):

PQ.p0.v After Scaling (active demands):  
[6.6, 4.95, 2.5718, 5.742, 1.32, 3.52, 3.6234, 1.738, 7.48, 3.014,  
 2.7225, 3.3946, 2.464, 1.529, 3.091, 2.266, 3.1185, 0.88, 4.4]

PQ.q0.v After Scaling (reactive demands):  
[2.75, 2.024, 9.24, 1.936, 0.33, 1.683, 3.553, 0.33, 1.133, 1.265,  
 0.9306, –1.0142, 0.5192, 0.187, 0.8305, 0.3036, 1.3959, 0.44, 2.75]

• Each entry corresponds to one of the 19 PQ buses in the standard 39-bus layout.  
• All values are exactly 1.1× the original case demands (e.g. original P=6.0 → 6.6 pu).  
• Although a full power-flow run is performed, only the updated load vectors are displayed here. You could extend this to extract bus voltages, line flows, generator outputs, etc., under the 10% heavier load."
"Code: import andes
import numpy as np

ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=True,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

# Scale up (perturb) the voltage states of both p0 and q0 by 10%. 
ssa.PQ.set(
            src='p0', 
            idx= ssa.PQ.idx.v, 
            attr='v',
            value= 1.1 * ssa.PQ.p0.v
        )

ssa.PQ.set(
            src='q0', 
            idx= ssa.PQ.idx.v, 
            attr='v',
            value= 1.1 * ssa.PQ.q0.v
        )

# Change specific load based on idx
# Note: check the case (excel) file to get the correct idx
ssa.PQ.set(
            src='p0', 
            idx= ['PQ_1', 'PQ_10'], 
            attr='v',
            value= np.array([8, 4])
        )

ssa.PQ.set(
            src='q0', 
            idx= ['PQ_1', 'PQ_10'], 
            attr='v',
            value= np.array([2, 1])
        )

ssa.PFlow.run()

print(""PQ.p0.v After Change:"", ssa.PQ.p0.v)
print(""PQ.q0.v After Change:"", ssa.PQ.q0.v)


# Load the IEEE 39-bus case, increase all PQ load active and reactive powers by 10%, modify specific loads by index, then run a power-flow simulation and display the updated values.
                Code Output: STDOUT:
PQ.p0.v After Change: [8.     4.95   2.5718 5.742  1.32   3.52   3.6234 1.738  7.48   4.
 2.7225 3.3946 2.464  1.529  3.091  2.266  3.1185 0.88   4.4   ]
PQ.q0.v After Change: [ 2.      2.024   9.24    1.936   0.33    1.683   3.553   0.33    1.133
  1.      0.9306 -1.0142  0.5192  0.187   0.8305  0.3036  1.3959  0.44
  2.75  ]","The snippet demonstrates how to load the IEEE‐39 bus test case in Andes, programmatically perturb all PQ‐load injections by +10%, then override two specific loads (PQ_1 and PQ_10), run a full AC power‐flow, and finally inspect the updated active/reactive injections. Here are the key steps and results an EE engineer would care about:

1. Case loading  
   • andes.load(…setup=True, no_output=True, default_config=False) brings in the IEEE-39 network.  
2. Global 10% scaling of all PQ loads  
   • Active powers:  
     p0.v ← 1.1 · previous p0.v  
   • Reactive powers:  
     q0.v ← 1.1 · previous q0.v  
3. Override two loads by index  
   • Bus “PQ_1”: set p0.v=8.0 MW, q0.v=2.0 MVAr  
   • Bus “PQ_10”: set p0.v=4.0 MW, q0.v=1.0 MVAr  
4. Run AC power flow  
   • ssa.PFlow.run() solves for voltages/currents with the new injections.  
5. Final PQ injections (p0.v in MW, q0.v in MVAr) that were actually used in the power‐flow:  

   Active powers p0.v =  
   [ 8.0000, 4.9500, 2.5718, 5.7420, 1.3200, 3.5200,  
     3.6234, 1.7380, 7.4800, 4.0000, 2.7225, 3.3946,  
     2.4640, 1.5290, 3.0910, 2.2660, 3.1185, 0.8800, 4.4000 ]

   Reactive powers q0.v =  
   [ 2.0000, 2.0240, 9.2400, 1.9360, 0.3300, 1.6830,  
     3.5530, 0.3300, 1.1330, 1.0000, 0.9306, –1.0142,  
     0.5192, 0.1870, 0.8305, 0.3036, 1.3959, 0.4400, 2.7500 ]

Notes:  
– Entries 1 and 10 (zero‐based indices 0 and 9) correspond to your manual overrides.  
– The remaining entries are simply the original IEEE-39 load powers × 1.1.  
– These arrays (ssa.PQ.p0.v and ssa.PQ.q0.v) become the fixed injections for the subsequent power‐flow solution."
"Code: import andes
import numpy as np

ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=False,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

ssa.setup()

# change power reference of PV/Slack bus 

# PV bus
# Note: check the case (excel) file to get the correct idx
# If the idx is number, then use idx= [1, 2] instead of idx= ['1', '2']
ssa.PV.set(
            src='p0', 
            idx= [1, 2], 
            attr='v',
            value= np.array([5, 7])
        )

ssa.PV.set(
            src='q0', 
            idx= [1, 2], 
            attr='v',
            value= np.array([2, 2.5])
        )

ssa.PFlow.run()

print(""PV.p0.v After Change:"", ssa.PV.p0.v)
print(""PV.q0.v After Change:"", ssa.PV.q0.v)


# Load the IEEE 39-bus case, modify the active and reactive power setpoints for selected PV buses, then run a power-flow simulation and display the updated values.
                Code Output: STDOUT:
PV.p0.v After Change: [5.   7.   6.5  6.32 5.08 6.5  5.6  5.4  8.3  1.   1.5  2.   2.5 ]
PV.q0.v After Change: [2.      2.5     4.46722 2.4294  2.29094 3.61684 1.85829 1.5809  1.87815
 0.27003 0.27003 0.27003 0.27003]","The script does the following steps on the IEEE-39 bus case:

1. Loads the case via ANDES without automatically running the setup.  
2. Calls `ssa.setup()` to build the network model.  
3. For PV buses with internal indices 1 and 2 (corresponding to bus numbers “1” and “2” in the Excel file), it overrides the active‐power and reactive‐power set-points to  
   – P₀ = [5.0, 7.0] pu  
   – Q₀ = [2.0, 2.5] pu  
4. Runs a full AC power-flow (`ssa.PFlow.run()`), then prints out the entire P₀ and Q₀ vectors for all 13 PV buses in the case.

Output arrays (bus index ⇒ P₀, Q₀):  
1 ⇒ 5.00 pu, 2.00 pu  
2 ⇒ 7.00 pu, 2.50 pu  
3 ⇒ 6.50 pu, 4.46722 pu  
4 ⇒ 6.32 pu, 2.42940 pu  
5 ⇒ 5.08 pu, 2.29094 pu  
6 ⇒ 6.50 pu, 3.61684 pu  
7 ⇒ 5.60 pu, 1.85829 pu  
8 ⇒ 5.40 pu, 1.58090 pu  
9 ⇒ 8.30 pu, 1.87815 pu  
10 ⇒ 1.00 pu, 0.27003 pu  
11 ⇒ 1.50 pu, 0.27003 pu  
12 ⇒ 2.00 pu, 0.27003 pu  
13 ⇒ 2.50 pu, 0.27003 pu  

Key takeaways for an EE user:  
• You can selectively override PV-bus P and Q setpoints by index before running a load-flow.  
• The printed vectors confirm that only the specified indices (1 and 2) changed, while the other 11 PV buses retain their original defaults.  
• This workflow is useful when you need to study the impact of changing generator injections on system voltages, flows, or reactive margins in a standard test case."
"Code: import andes
import numpy as np

ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=True,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

# Slack bus
# Note: check the case (excel) file to get the correct src and idx
ssa.Slack.set(
            src='v0', 
            idx= 10, 
            attr='v',
            value= np.array([1])  # value= 1  works too
        )

ssa.Slack.set(
            src='a0', 
            idx= 10, 
            attr='v',
            value= np.array([0])  # value= 0  works too
        )

ssa.PFlow.run()

print(""Slack.v0.v After Update"", ssa.Slack.v0.v)
print(""Slack.a0.v After Update"", ssa.Slack.a0.v)


# Load the IEEE 39-bus case, update the voltage magnitude and angle setpoints for the Slack bus, then run a power-flow simulation and display the updated values.
                Code Output: STDOUT:
Slack.v0.v After Update [1.]
Slack.a0.v After Update [0.]","The snippet does the following steps, aimed at an IEEE-39 bus power‐flow in andes:

1. Load the IEEE-39 case (from the provided Excel file) into an andes “steady‐state” object (`ssa`), with custom configuration  
2. Specify bus-10 as the slack (swing) bus by setting:  
   • Voltage magnitude (v0.v) = 1.0 pu  
   • Voltage angle  (a0.v) = 0.0 rad  
3. Run the power‐flow (`ssa.PFlow.run()`)  
4. Print out the slack‐bus voltage magnitude and angle after the solve.

Output confirms that the slack‐bus remained at exactly the setpoints:
• Slack.v0.v After Update [1.]  
• Slack.a0.v After Update [0.]  

This shows that the slack‐bus voltage and angle are enforced by andes and retained through the power‐flow solution."
"Code: import andes

ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=False,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

print(""PQ Table of Case:"", ssa.PQ.as_df())

# Load the IEEE 39-bus case and display the PQ load table as a DataFrame.
                Code Output: STDOUT:
PQ Table of Case:        idx  u   name  bus     Vn     p0     q0  vmax  vmin  owner
uid                                                              
0     PQ_1  1   PQ_1    3  345.0  6.000  2.500   1.2   0.8      1
1     PQ_2  1   PQ_2    4  345.0  4.500  1.840   1.2   0.8      1
2     PQ_3  1   PQ_3    7  345.0  2.338  8.400   1.2   0.8      1
3     PQ_4  1   PQ_4    8  345.0  5.220  1.760   1.2   0.8      1
4     PQ_5  1   PQ_5   12  138.0  1.200  0.300   1.2   0.8      1
5     PQ_6  1   PQ_6   15  345.0  3.200  1.530   1.2   0.8      1
6     PQ_7  1   PQ_7   16  345.0  3.294  3.230   1.2   0.8      1
7     PQ_8  1   PQ_8   18  345.0  1.580  0.300   1.2   0.8      1
8     PQ_9  1   PQ_9   20  138.0  6.800  1.030   1.2   0.8      1
9    PQ_10  1  PQ_10   21  345.0  2.740  1.150   1.2   0.8      1
10   PQ_11  1  PQ_11   23  345.0  2.475  0.846   1.2   0.8      1
11   PQ_12  1  PQ_12   24  345.0  3.086 -0.922   1.2   0.8      1
12   PQ_13  1  PQ_13   25  345.0  2.240  0.472   1.2   0.8      1
13   PQ_14  1  PQ_14   26  345.0  1.390  0.170   1.2   0.8      1
14   PQ_15  1  PQ_15   27  345.0  2.810  0.755   1.2   0.8      1
15   PQ_16  1  PQ_16   28  345.0  2.060  0.276   1.2   0.8      1
16   PQ_17  1  PQ_17   29  345.0  2.835  1.269   1.2   0.8      1
17   PQ_18  1  PQ_18   31   34.5  0.800  0.400   1.2   0.8      1
18   PQ_19  1  PQ_19   39  345.0  4.000  2.500   1.2   0.8      1","The snippet uses ANDES to load the IEEE-39 bus test case (from the Excel file) but postpones the standard “setup” and any power-flow solve. It then prints out the raw PQ load table as a pandas DataFrame. Key points for an EE reader:

 • Configuration  
   – `setup=False` means no bus/admittance matrix or device modeling has yet been built; you would normally follow with `ssa.setup()` (and then a power‐flow or dynamic simulation).  
   – `no_output=True` silences ANDES’s built-in reporting.  
   – `default_config=False` prevents any default generator/load assignments beyond what’s in the spreadsheet.  

 • PQ Table contents (19 loads)  
   – idx/name/bus: identifies each load (PQ_1 … PQ_19) and its bus number.  
   – Vn: nominal voltage level (mostly 345 kV; buses 12 & 20 at 138 kV; bus 31 at 34.5 kV).  
   – p0, q0: active/reactive power injections (in per-unit or MW/MVAr depending on your base). The largest load is 6.8 (≈PQ_9 at bus 20) and the smallest is 0.8 (bus 31). Note PQ_12 has q0=–0.922, indicating net reactive injection rather than consumption.  
   – vmax/vmin: voltage limits (±20% around nominal: 1.2 pu / 0.8 pu).  
   – owner: a customer or utility ID (all set to 1 here).  

This table is exactly the list of static loads that will be placed on those buses once you call `ssa.setup()` and run your load‐flow or dynamic studies."
"Code: import andes
import pandas as pd


path = ""ieee39_base.xlsx""

# Load all sheets at once as a dict of DataFrames
all_sheets = pd.read_excel(path, sheet_name=None)

print(""Workbook Sheets and Their Column Headers:"")
for sheet_name, df in all_sheets.items():
    print(f""Sheet: {sheet_name}"")
    print(f""Columns: {list(df.columns)}"")
    print(""\n"")


ssa = andes.load(
    path,
    setup=False,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

ssa.setup()
ssa.PFlow.run()


# 1. Load the workbook and list sheets
xls = pd.ExcelFile(""ieee39_base.xlsx"")
sheet_names = xls.sheet_names
first_sheet = sheet_names[0]

# 2. Parse the first sheet to get its column headers
df0 = xls.parse(first_sheet)
headers = df0.columns.tolist()

# 3. Make sure there are at least 7 columns
if len(headers) < 7:
    raise ValueError(f""Sheet '{first_sheet}' Only Has {len(headers)} Columns -- Can't Get the 7th Header"")

# 4. Get the 7th header (index 6)
seventh_header = headers[6]

# 5. Finally, pull its `.v` array from ANDES
values = getattr(getattr(ssa, first_sheet), seventh_header).v

print(f""1st Sheet: '{first_sheet}'"")
print(f""7th Header: '{seventh_header}'"")
print(f""Values ({first_sheet}.{seventh_header}.v):\n"", values)


# Load the IEEE 39-bus workbook, list all sheets with their column headers, run a power-flow simulation, then retrieve and display the values of the 7th column from the first sheet using ANDES.
                Code Output: STDERR:
Traceback (most recent call last):
  File ""/home/chen541/ANDES_Data/PowerFlow_Specific/code_examples/powerflow-ex9.py"", line 8, in <module>
    all_sheets = pd.read_excel(path, sheet_name=None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/chen541/miniconda3/envs/power-simulation-env/lib/python3.12/site-packages/pandas/io/excel/_base.py"", line 495, in read_excel
    io = ExcelFile(
         ^^^^^^^^^^
  File ""/home/chen541/miniconda3/envs/power-simulation-env/lib/python3.12/site-packages/pandas/io/excel/_base.py"", line 1550, in __init__
    ext = inspect_excel_format(
          ^^^^^^^^^^^^^^^^^^^^^
  File ""/home/chen541/miniconda3/envs/power-simulation-env/lib/python3.12/site-packages/pandas/io/excel/_base.py"", line 1402, in inspect_excel_format
    with get_handle(
         ^^^^^^^^^^^
  File ""/home/chen541/miniconda3/envs/power-simulation-env/lib/python3.12/site-packages/pandas/io/common.py"", line 882, in get_handle
    handle = open(handle, ioargs.mode)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: 'ieee39_base.xlsx'

ERROR conda.cli.main_run:execute(125): `conda run python code_examples/powerflow-ex9.py` failed. (See above for error)

Return Code: 1","Here’s what the script is doing and what happened when it ran:

1. Purpose of the Code  
   - Load an IEEE-39 bus data workbook (“ieee39_base.xlsx”) into pandas and ANDES.  
   - List every sheet name and its column headers.  
   - Initialize ANDES without outputs, set it up, and run a power‐flow.  
   - Parse the first sheet again in pandas, grab its 7th column header, and then pull that variable’s `.v` array from the ANDES steady-state model.

2. Key Steps in the Script  
   a. `pd.read_excel(path, sheet_name=None)` to load all sheets into a dict of DataFrames, then print each sheet’s name and columns.  
   b. `andes.load(…)` to load the same file into an ANDES steady-state analysis object (`ssa`), followed by `ssa.setup()` and `ssa.PFlow.run()`.  
   c. Reopen the Excel file via `pd.ExcelFile`, parse the first sheet, ensure at least 7 columns exist, extract the 7th header (Python index 6), and then retrieve the corresponding ANDES variable’s value vector (`.v`) from `ssa`.

3. What Actually Happened  
   - The very first pandas call to open “ieee39_base.xlsx” failed with FileNotFoundError:  
     “No such file or directory: 'ieee39_base.xlsx'”  
   - Because pandas could not find the workbook, nothing downstream (sheet listing, ANDES setup or power-flow, extraction of the 7th column’s values) could execute.

4. Implications & Next Steps for an EE User  
   - Make sure the Excel file is in the working directory of the script or provide an absolute path.  
   - Verify the file name—spelling, extension, or location—so that pandas (and ANDES) can load it.  
   - Once the workbook loads successfully, you’ll get:  
     • A printout of every sheet and its columns.  
     • The ANDES power-flow result in memory.  
     • Extraction of the 7th column’s numerical values from the first sheet for further analysis."
"Code: import andes
import numpy as np


ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=False,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

ssa.setup()
ssa.PFlow.run()


# Total number of generators
generators = np.concatenate((ssa.PV.pmin.v, ssa.Slack.pmin.v))

print(""Toal Generators:"", len(generators))


# Total number of load rows
loads = ssa.PQ.p0.v

print(""Total Loads:"", len(loads))


# Load the IEEE 39-bus case, run a power-flow simulation, and display the total number of generators and loads in the system.
                Code Output: STDOUT:
Toal Generators: 14
Total Loads: 19","The script performs the following steps:  
1. Uses ANDES to load the IEEE-39 bus test case (from its Excel file) with no automatic setup or output.  
2. Calls `ssa.setup()` and then runs a full power-flow (`ssa.PFlow.run()`).  
3. Builds two arrays of “generator” devices by concatenating:  
   – All PV‐type machines (`ssa.PV.pmin.v`)  
   – The slack bus machine(s) (`ssa.Slack.pmin.v`)  
   and then takes the length of that combined array.  
4. Reads the PQ‐load vector (`ssa.PQ.p0.v`) and reports its length.  

Resulting counts:  
– Total number of generating units (PV + slack): 14  
– Total number of load injections (PQ buses): 19  

In other words, in this ANDES‐modeled IEEE 39-bus case you have 14 voltage-controlled machines (including the slack) supplying a system that has 19 distinct load “nodes.”"
"Code: import andes
import numpy as np


ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=True,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

ssa.PFlow.run()


generator_capacity = np.concatenate([ssa.PV.Sn.v, ssa.Slack.Sn.v])  # capacity for each generator

# Compute overall extremes
max_capacity = np.max(generator_capacity)
min_capacity = np.min(generator_capacity)

print(f""Maximum Generator Capacity: {max_capacity} MVA"")
print(f""Minimum Generator Capacity: {min_capacity} MVA"")


# Load the IEEE 39-bus case, run a power-flow simulation, and display the maximum and minimum generator capacities in the system.
                Code Output: STDOUT:
Maximum Generator Capacity: 1684.1 MVA
Minimum Generator Capacity: 275.0 MVA","The script does the following:

1. Uses ANDES to load and set up the IEEE 39-bus test case (the New England system) in Python (from an Excel file).  
2. Runs a steady‐state power-flow (PFlow) solution.  
3. Extracts each generator’s rated apparent power (Sn) for all PV units plus the slack unit.  
4. Computes and prints the maximum and minimum generator ratings in the system.  

Results:  
• Maximum generator capacity = 1684.1 MVA  
• Minimum generator capacity = 275.0 MVA  

From an EE perspective, this tells you that in the IEEE-39 model the largest unit (typically the slack/reference generator) is rated at 1684 MVA, while the smallest PV‐type unit is 275 MVA. These extremes can guide equipment sizing, stability margins and contingency analyses."
"Code: import andes
import numpy as np


ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=True,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

ssa.PFlow.run()


# Grab all voltage magnitudes (p.u.)
v_mag = np.abs(ssa.Bus.v.v)

# Find the index of the maximum voltage
idx_max = int(np.argmax(v_mag))

# Retrieve the bus idx from Bus sheet
bus_idx = ssa.Bus.idx.v
idx_max_sheet = bus_idx[idx_max]

# Retrieve the bus ID from BUS sheet
bus_ids = ssa.Bus.uid
max_bus = bus_ids[idx_max_sheet]

max_v = v_mag[idx_max]

print(f""Bus UID {max_bus} has the Highest Voltage: {max_v} p.u."")


# Load the IEEE 39-bus case, run a power-flow simulation, and identify the bus with the highest voltage magnitude, displaying its UID and value.
                Code Output: STDOUT:
Bus UID 35 has the Highest Voltage: 1.0635 p.u.","The provided Python snippet uses the ANDES toolbox together with NumPy to:

1. Load the IEEE 39-bus test case (from “ieee39.xlsx”) into an ANDES steady-state analysis object (`ssa`).
2. Run a full Newton–Raphson power‐flow (`ssa.PFlow.run()`).
3. Extract all bus voltages in per‐unit:  
   v_mag = |ssa.Bus.v.v|  
   (This yields a length-39 array of voltage magnitudes.)
4. Locate the index of the maximum entry in that array via `np.argmax`.
5. Map that array index back to the bus sheet index (`ssa.Bus.idx.v`) and thence to the bus UID (`ssa.Bus.uid`).
6. Print out which bus has the highest voltage.

Code Output  
    Bus UID 35 has the Highest Voltage: 1.0635 p.u.

Key takeaway for power-systems work:  
• In the IEEE-39 case, bus “35” exhibits the largest voltage magnitude at 1.0635 pu after convergence.  
• This identifies the “tightest” voltage headroom on the system (useful for reactive reserve or tap‐changer settings)."
"Code: import andes
import numpy as np


ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=False,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

ssa.setup()
ssa.PFlow.run()


# Read per‐unit outputs
p_pv = ssa.PV.p.v  # all PV‐type gens
p_slack = ssa.Slack.p.v  # the slack‐bus gen

# Combine into one array
p_all_pu = np.concatenate([p_pv, p_slack])

# Convert to MW
p_all_mw = p_all_pu * ssa.config.mva

# Find max
idx_max = np.argmax(p_all_mw)

# Map back to names
names_all = ssa.PV.name.v + ssa.Slack.name.v

print(f""Max Generator: {names_all[idx_max]} at {p_all_mw[idx_max]} MW"")


# Load the IEEE 39-bus case, run a power-flow simulation, and find the generator with the highest active power output, displaying its name and output in MW.
                Code Output: STDOUT:
Max Generator: 9 at 830.0000000000001 MW","The script loads the IEEE-39 bus case, runs a steady‐state power‐flow, and pulls out all PV‐type and the slack‐bus real‐power injections (in per-unit on the case’s MVA base). It then converts them to MW and finds the single largest generator output. In this run the largest producer is generator “9” delivering 830 MW (i.e. 8.3 pu on a 100 MVA base)."
"Code: import andes
import numpy as np

ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=False,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

ssa.setup()
ssa.PFlow.run()


print(""Before:"")

# Total number of generators
generators = np.concatenate([ssa.PV.pmin.v, ssa.Slack.pmin.v])

print(""Toal Generators:"", len(generators))


# Total number of load rows
loads = ssa.PQ.p0.v

print(""Total Loads:"", len(loads))


ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=False,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

# Add new load
# Remove load can be done by setting the p0 and q0 to 0
ssa.add(model=""PQ"", param_dict=dict(bus=2, 
                                    idx=""PQ_20"", 
                                    p0=0.5, 
                                    q0=0.2
                                    ))

# Add new generator
# Remove generator can be done by setting the p0 and q0 to 0
ssa.add(model=""PV"", param_dict=dict(bus=15, 
                                    idx='15', 
                                    p0=0.5, 
                                    q0=0.2,
                                    pmax=5,
                                    pmin=0,
                                    qmax=2,
                                    qmin=-2,
                                    v0=1.0,
                                    ))

ssa.setup()
ssa.PFlow.run()


print(""After:"")

# Total number of generators
generators = np.concatenate([ssa.PV.pmin.v, ssa.Slack.pmin.v])

print(""Toal Generators:"", len(generators))


# Total number of load rows
loads = ssa.PQ.p0.v

print(""Total Loads:"", len(loads))


# Load the IEEE 39-bus case, run a power-flow simulation, and display the total numbers of generators and loads before and after adding a new load and a new PV generator.
                Code Output: STDOUT:
Before:
Toal Generators: 14
Total Loads: 19
After:
Toal Generators: 15
Total Loads: 20","The script uses ANDES to load the IEEE-39 bus system, runs a steady-state (power‐flow) solve, and then reports the counts of generator and load models before and after manually adding one PQ load and one PV generator.  

Key points:  
1. Initial “ieee39.xlsx” case (no customizations):  
   • Generators (PV + Slack) = 14  
   • Loads (PQ) = 19  

2. Additions:  
   – A new PQ‐type load at bus 2 with p₀=0.5 pu, q₀=0.2 pu  
   – A new PV‐type generator at bus 15 with p₀=0.5 pu, q₀=0.2 pu, p_min=0, p_max=5, q_min=–2, q_max=2, v₀=1.0 pu  

3. After re‐running the power flow:  
   • Generators = 15  
   • Loads = 20  

Thus, each addition incremented the respective model count by one."
"Code: import andes
import numpy as np


ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx'),
    setup=True,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

ssa.PFlow.run()


# Grab all bus voltage angles (radians)
angles_rad = ssa.Bus.a.v

# Find the buses with the maximum and minimum angles
idx_max = int(np.argmax(angles_rad))
idx_min = int(np.argmin(angles_rad))

# Convert positions -> sheet indices -> UIDs
bus_idx = ssa.Bus.idx.v  # mapping from position -> sheet index
bus_ids = ssa.Bus.uid  # array of bus UIDs keyed by sheet index
sheet_max = bus_idx[idx_max]
sheet_min = bus_idx[idx_min]
bus_max = bus_ids[sheet_max]
bus_min = bus_ids[sheet_min]

max_angle = angles_rad[idx_max]
min_angle = angles_rad[idx_min]
diff_angle = max_angle - min_angle

print(f""Bus UID {bus_max} has the Largest Angle: {max_angle} Radians"")
print(f""Bus UID {bus_min} has the Smallest Angle: {min_angle} Radians"")
print(f""Maximum Bus Angle Difference is Between {bus_max} and {bus_min}: {diff_angle} Radians"")


# Load the IEEE 39-bus case, run a power-flow simulation, and identify the buses with the largest and smallest voltage angles (in radians), displaying their UIDs, values, and the maximum angle difference.
                Code Output: STDOUT:
Bus UID 37 has the Largest Angle: 0.2529792546952598 Radians
Bus UID 38 has the Smallest Angle: -0.1912880860185785 Radians
Maximum Bus Angle Difference is Between 37 and 38: 0.4442673407138383 Radians","The provided script uses the ANDES Python API to load the IEEE-39 bus test case, run a steady-state power‐flow, retrieve all bus voltage angles in radians, and then identify which two buses have the largest separation in phase angle.  Below is a concise, engineer-focused summary:

1. Case setup and solution  
   • The IEEE-39 network is loaded directly from its Excel definition (no additional configuration files).  
   • A Newton–Raphson power‐flow is executed via `ssa.PFlow.run()`.

2. Extraction of bus voltage angles  
   • All bus voltage phase angles (in radians) are read from `ssa.Bus.a.v`.  
   • NumPy’s `argmax`/`argmin` locate the positions of the maximum and minimum angles in that vector.  
   • These positions are mapped back to the original bus UIDs.

3. Key results  
   • Bus 37 has the largest voltage angle:  
     – θ₃₇ =  0.25298 rad  (≈ 14.51°)  
   • Bus 38 has the smallest voltage angle:  
     – θ₃₈ = –0.19129 rad  (≈ –10.96°)  
   • The maximum phase‐angle separation in the system is between buses 37 and 38:  
     – Δθ = θ₃₇ – θ₃₈ = 0.44427 rad (≈ 25.47°)

4. Engineering significance  
   • A 25.5° phase difference in a transmission network of this size is typical but should be monitored—large angle spreads can indicate stressed conditions or may limit power transfer.  
   • Identifying the “most advanced” and “most lagging” buses helps pinpoint where stability margins are tightest, which is critical for contingency analysis and real-time monitoring."
"Code: import andes
import numpy as np


ssa = andes.load(andes.get_case('ieee39/ieee39.xlsx'))

ssa.PFlow.run()


# Grab all bus voltage angles (radians)
angles_rad = ssa.Bus.a.v
angles_deg = np.degrees(angles_rad)

# Find the buses with the maximum and minimum angles
idx_max = int(np.argmax(angles_deg))
idx_min = int(np.argmin(angles_deg))

# Convert positions -> sheet indices -> UIDs
bus_idx = ssa.Bus.idx.v  # mapping from position -> sheet index
bus_ids = ssa.Bus.uid  # array of bus UIDs keyed by sheet index
sheet_max = bus_idx[idx_max]
sheet_min = bus_idx[idx_min]
bus_max = bus_ids[sheet_max]
bus_min = bus_ids[sheet_min]

max_angle = angles_deg[idx_max]
min_angle = angles_deg[idx_min]
diff_angle = max_angle - min_angle

print(f""Bus UID {bus_max} has the Largest Angle: {max_angle}°"")
print(f""Bus UID {bus_min} has the Smallest Angle: {min_angle}°"")
print(f""Maximum Bus Angle Difference is Between {bus_max} and {bus_min}: {diff_angle}°"")


# Load the IEEE 39-bus case, run a power-flow simulation, and identify the buses with the largest and smallest voltage angles in degrees, displaying their UIDs, values, and the maximum angle difference.
                Code Output: STDOUT:
Bus UID 37 has the Largest Angle: 14.494643598403501°
Bus UID 38 has the Smallest Angle: -10.959999999999999°
Maximum Bus Angle Difference is Between 37 and 38: 25.4546435984035°","Here’s a concise engineering‐focused summary of what the script does and what the results mean:

1. Case setup and power‐flow  
   • The script loads the IEEE 39‐bus test case via the ANDES library and runs a full AC power‐flow.  
   • It then extracts each bus’s voltage angle in radians and converts them to degrees.

2. Identification of extreme angles  
   • It locates which bus has the highest voltage angle and which has the lowest by scanning the array of angles.  
   • It maps those array indices back to the original bus UIDs (as defined in the Excel case file).

3. Results  
   • Bus 37 registered the largest voltage angle at +14.4946°.  
   • Bus 38 registered the smallest voltage angle at –10.9600°.  
   • The maximum phase difference across the network is therefore 14.4946° – (–10.9600°) = 25.4546°.

4. Engineering implications  
   • A 25.45° separation is a measure of the maximum phase shift between any two buses—in this case between buses 37 and 38.  
   • Large phase‐angle differences can indicate heavily loaded corridors or potential stability limits.  
   • Knowing which buses define the maximum angle swing helps target monitoring or control actions (e.g., redispatch, series compensation) to reduce stress on critical corridors."
"Code: import andes
import numpy as np


ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx')
)

ssa.PFlow.run()


# Read per‐unit outputs
p_pv = ssa.PV.p.v  # all PV‐type gens
p_slack = ssa.Slack.p.v  # the slack‐bus gen

# Combine into one array
p_all_pu = np.concatenate([p_pv, p_slack])

# Convert to MW
p_all_mw = p_all_pu * ssa.config.mva

# Find min
idx_max = np.argmin(p_all_mw)

# Map back to names
names_all = ssa.PV.name.v + ssa.Slack.name.v

print(f""Min Generator: {names_all[idx_max]} at {p_all_mw[idx_max]} MW"")


# Load the IEEE 39-bus case, run a power-flow simulation, and find the generator with the lowest active power output, displaying its name and output in MW.
                Code Output: STDOUT:
Min Generator: 10 at 41.42181745506186 MW","The script does the following steps in an IEEE 39-bus (New England) system using ANDES:  
1. Loads the “ieee39.xlsx” data and runs an AC power‐flow.  
2. Extracts every PV‐type generator’s active‐power output (pu) plus the slack‐bus generator’s output (pu).  
3. Concatenates those and multiplies by the case base MVA (ssa.config.mva, 100 MVA by default) to get MW values.  
4. Finds which generator has the smallest active‐power dispatch.  

Result:  
– The smallest generator output is at “Generator 10,” producing about 41.42 MW (≈0.414 pu on a 100 MVA base)."
"Code: import andes
import numpy as np


ssa = andes.load(
    andes.get_case('ieee39/ieee39.xlsx')
)

ssa.PFlow.run()


# Read per‐unit outputs
q_pv = ssa.PV.q.v  # all PV‐type gens
q_slack = ssa.Slack.q.v  # the slack‐bus gen

# Combine into one array
q_all_pu = np.concatenate([q_pv, q_slack])

# Convert to Mvar
q_all_mvar = q_all_pu * ssa.config.mva

# Find min
idx_max = np.argmin(q_all_mvar)

# Map back to names
names_all = ssa.PV.name.v + ssa.Slack.name.v

print(f""Min Generator: {names_all[idx_max]} at {q_all_mvar[idx_max]} Mvar"")


# Load the IEEE 39-bus case, run a power-flow simulation, and find the generator with the lowest reactive power output, displaying its name and output in Mvar.
                Code Output: STDOUT:
Min Generator: 14 at -493.0511502744088 Mvar","The script you provided does the following:

1. Loads the IEEE 39‐bus test case via ANDES and runs a full AC power‐flow.  
2. Extracts the per‐unit reactive power outputs (Q) of all PV‐type generators plus the single slack generator.  
3. Converts those per‐unit Q values into Mvar by multiplying by the system MVA base.  
4. Finds which generator has the smallest (most negative) Q output and prints its name and Mvar value.  

In your run, the output was:

   Min Generator: 14 at –493.0511502744088 Mvar

Interpretation for an EE:  
• “14” is the identifier/name of the generator (in ANDES this corresponds to the generator at bus 14).  
• Its reactive injection is –493.05 Mvar (i.e. it is absorbing about 493 Mvar from the system).  
• This large negative Q suggests that, under the base‐case loading, the machine at bus 14 is driven to its reactive absorption limit (or close to it). That makes it a potential bottleneck for voltage support and may require reactive support via switched shunts or SVC/STATCOM nearby."
"Code: import andes
import numpy as np


ssa = andes.load(
    andes.get_case('5bus/pjm5bus.xlsx')
)

ssa.PFlow.run()


# Read per‐unit outputs
v0_pv = ssa.PV.v0.v  # all PV‐type gens
v0_slack = ssa.Slack.v0.v  # the slack‐bus gen

# Combine into one array
v0_all_gen = np.concatenate([v0_pv, v0_slack])

print(""Initial Voltage for All Generators:"", v0_all_gen)


# Print the initial voltage of all generators.
                Code Output: STDOUT:
Initial Voltage for All Generators: [1. 1. 1. 1.]","Here’s what the snippet is doing and what its output tells you:

1. Case loading and power‐flow run  
   - It uses ANDES to load a 5-bus PJM test case (xlsx format).  
   - It then runs a full AC power-flow (PFlow.run()).

2. Voltage extraction  
   - `ssa.PV.v0.v` grabs the “v0” (initial guess) voltages at all PV-type generator buses.  
   - `ssa.Slack.v0.v` grabs the “v0” voltage at the slack bus generator.  
   - Those two arrays are concatenated.

3. Printed result  
   - Initial (v0) voltages for all generators come out as [1. 1. 1. 1.].

Electrical‐engineering takeaways  
- All four generators (PV buses plus the single slack bus) were initialized at exactly 1.0 pu.  
- This reflects the flat‐start default in ANDES (v0), not necessarily the final converged voltages.  
- If you want the post‐iteration voltages, you’d inspect something like `ssa.PV.v.v` and `ssa.Slack.v.v` (no “0”)."
"Code: import andes


ssa = andes.load(
    andes.get_case('GBnetwork/GBnetwork.xlsx')
)

ssa.PFlow.run()


# Read per‐unit outputs
v0_pq = ssa.PQ.v0.v  # all PQ‐type loads

print(""Initial Voltage for All Loads:"", v0_pq)


# Print the initial voltage of all loads.
                Code Output: STDOUT:
Initial Voltage for All Loads: [1.053  1.0512 1.0515 1.053  1.053  1.0523 1.0496 1.0381 1.053  1.0524
 1.0527 0.947  1.042  1.053  1.0198 1.0408 1.0407 1.0429 1.0467 1.044
 1.0463 1.0486 1.0486 1.0498 1.053  1.0465 1.0511 1.045  1.053  1.051
 1.053  1.0524 1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053
 1.053  1.053  1.053  1.053  1.053  1.053  1.0498 0.9968 1.0068 1.053
 1.0009 1.0015 1.0474 1.053  1.0248 1.02   1.053  1.053  1.0469 1.053
 1.053  1.053  0.947  1.053  1.0398 1.053  1.053  1.053  1.053  1.053
 1.0235 1.053  1.0519 1.0444 1.053  1.053  1.053  1.053  1.053  1.053
 1.053  1.053  1.05   1.053  1.053  1.053  1.0283 1.053  1.025  1.053
 1.0328 1.0473 1.053  1.053  1.0521 1.053  1.053  1.0089 1.0139 1.053
 1.053  1.053  1.053  1.053  1.0504 1.053  1.053  1.053  1.053  1.053
 1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053
 1.053  1.053  1.053  1.053  1.053  1.053  1.053  0.962  1.0218 1.021
 1.053  1.053  1.0529 1.053  1.0487 1.0459 1.0417 1.053  1.053  1.053
 1.053  1.049  1.0037 1.0035 1.053  1.053  1.0294 1.053  1.053  0.9733
 1.0499 1.0269 1.027  1.053  1.053  1.053  1.053  1.0284 1.0312 1.053
 1.053  1.053  1.0521 1.052  0.947  0.947  0.947  1.053  1.053  1.0523
 1.053  1.0335 1.0363 1.053  1.053  1.053  0.947  1.0019 0.947  0.947
 1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  0.983
 1.0516 1.0509 1.0505 1.0505 1.0448 1.0491 1.053  1.0511 1.053  1.053
 1.0521 1.0428 1.0459 1.053  1.0301 1.0488 1.0482 1.0528 1.0453 1.053
 1.0317 1.053  1.053  1.053  1.0503 1.053  1.0469 1.053  1.053  1.0518
 1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053
 0.947  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053
 1.0072 1.053  1.0505 1.0524 1.053  1.053  1.053  1.053  1.053  1.0252
 1.0237 1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053
 1.053  1.0525 1.053  1.053  1.0026 1.053  1.053  1.0147 0.9629 1.053
 1.053  1.053  0.9764 0.9676 1.053  1.053  0.9626 0.9956 1.053  1.053
 1.053  1.053  0.947  1.053  1.0512 1.053  1.0282 1.0327 1.053  1.053
 1.0263 0.9988 0.999  1.053  1.053  0.9837 0.9838 1.019  1.0233 1.0232
 1.053  1.053  0.9485 1.053  1.053  1.0458 1.053  1.0239 1.029  1.0265
 1.053  1.0473 0.9913 1.0123 1.053  1.053  1.053  1.053  1.0068 1.053
 1.053  1.053  1.053  1.053  1.053  1.053  1.0224 1.053  1.053  1.053
 1.053  1.053  1.0081 1.053  1.053  1.053  1.0048 1.053  1.053  1.053
 1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.0491
 1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053
 1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053
 1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053
 1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  0.947  1.053
 1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  1.053  0.9703
 1.053  1.0062 1.0237 1.053  1.053  1.053  1.053  1.053  1.053  1.0529
 1.053  1.053  1.053  1.053  1.0507 1.05   1.053  1.0474 1.053  1.053
 1.053  1.053  1.053  1.053  1.0252 1.0193 1.0059 1.0153 1.0272 1.015
 0.9744 1.0489 1.0285 1.0478 0.9983 1.0431 0.9825 0.9989 0.9472 1.0435
 1.053  1.0481 1.0513 1.0282 1.053  1.0481 1.053  1.053  1.053  1.053
 1.053  1.053  0.9934 1.053  1.053  1.053  1.053  1.053  1.053  1.0046
 1.053  1.053  1.053  1.053  1.053  1.053  1.0195 1.053  1.053  1.053
 1.053  1.053  1.053  1.053  1.053  1.0064 1.053  1.053  1.0071 1.053
 1.053  1.053  1.053 ]","The snippet does the following:  
 1. Imports the ANDES power‐flow library.  
 2. Loads a GB transmission network (“GBnetwork.xlsx”) into an ANDES case object.  
 3. Runs a full power‐flow (PFlow).  
 4. Pulls out the per‐unit voltage magnitudes at every PQ‐type load bus (ssa.PQ.v0.v) and prints them.  

Key observations from the printed array of roughly 400–500 load voltages:  
 • Min voltage = 0.947 pu (several loads hit exactly this)  
 • Max voltage = 1.053 pu (many loads at the slack or closely regulated buses)  
 • Most voltages lie in the 0.99–1.05 pu band, well within ±5% of nominal  
 • A handful of nodes sit right at 0.947 pu (–5.3%), slightly below the –5% threshold  

For a planning or operations engineer this tells you:  
 – The network is generally well‐regulated, with only a few buses marginally under –5%.  
 – Those low‐voltage pockets (0.947 pu) could benefit from local reactive support (e.g. LTC tap changes, capacitor banks).  
 – The high concentration at 1.053 pu simply reflects the slack/reference bus and downstream regulation set‐points.  

In other words, aside from a small number of slightly undervolted load buses, the GBnetwork’s PQ‐load voltages post‐flow fall within acceptable limits."
"Code: import andes


ssa = andes.load(
    andes.get_case('ei/EI_33.xlsx')
)

ssa.PFlow.run()


# Read per‐unit outputs
p0_slack = ssa.Slack.p0.v  # the slack‐bus gen

print(""Initial Power for All Slack Bus Components:"", p0_slack)


# Print the initial power of all slack bus components.
                Code Output: STDOUT:
Initial Power for All Slack Bus Components: [254.76207]","The script you ran does the following:

1. Uses ANDES to load a 33-bus test case from an Excel file (EI_33.xlsx).  
2. Executes a full AC power‐flow (`ssa.PFlow.run()`).  
3. Extracts the real‐power injection at the slack (reference) bus via `ssa.Slack.p0.v`.  
4. Prints that value.

Output summary:  
 • There is only one slack‐bus generator in this 33-bus case.  
 • Its real‐power output (in per‐unit) is 254.76207.  

What this means for an EE:  
 – In a per‐unit system (typically on a 100 MVA base unless otherwise specified), the slack generator is supplying roughly 254.76 pu of real power—i.e. 25 476 MW if the base is 100 MVA, or 254.76 MW on a 1 MVA base.  
 – That quantity represents the sum of all system loads plus network losses; checking it helps you verify that total generation matches total demand plus losses.  
 – If you see an unexpectedly large or small slack‐bus injection, it can indicate modelling errors (wrong load data, incorrect line impedances, etc.) or convergence issues in your power–flow solution."
"Code: import andes


ssa = andes.load(
    andes.get_case('ieee14/ieee14_full.xlsx')
)

ssa.PFlow.run()


bus_names = ssa.Bus.name.v

print(""Bus Names:"", bus_names)


# Print all Bus names.
                Code Output: STDOUT:
Bus Names: ['BUS1', 'BUS2', 'BUS3', 'BUS4', 'BUS5', 'BUS6', 'BUS7', 'BUS8', 'BUS9', 'BUS10', 'BUS11', 'BUS12', 'BUS13', 'BUS14']","The snippet does the following:  
1. Uses Andes’ Python API to load the IEEE‐14 bus test case from an Excel file.  
2. Runs a full AC power‐flow (“PFlow”) on that network.  
3. Extracts the list of bus names and prints them.  

The output confirms that all 14 buses in the IEEE‐14 model have been loaded and labeled as:  
  BUS1, BUS2, BUS3, BUS4, BUS5, BUS6, BUS7, BUS8, BUS9, BUS10, BUS11, BUS12, BUS13, BUS14  

For an EE engineer this tells you that your case has the standard 14‐bus topology in place. From here you could, for example, pull out per‐bus voltages (ssa.Bus.vm_pu.v), angles (ssa.Bus.va_degree.v), loads, generation, etc., now that the network is initialized and the power flow has converged."
"Code: import andes


ssa = andes.load(
    andes.get_case('kundur/kundur_full.xlsx')
)

ssa.PFlow.run()


print(""PV Bus Active Power"", ssa.PV.p.v)
print(""PV Bus Reactive Power"", ssa.PV.q.v)
print(""Slack Bus Active Power"", ssa.Slack.p.v)
print(""Slack Bus Reactive Power"", ssa.Slack.q.v)


# Print active and reactive power of all generators.
                Code Output: STDOUT:
PV Bus Active Power [7. 7. 7.]
PV Bus Reactive Power [2.2804802  2.32384586 1.06090951]
Slack Bus Active Power [7.26802921]
Slack Bus Reactive Power [1.09463368]","The Python snippet loads the full Kundur two‐area test system into ANDES, runs a steady‐state power‐flow, and then reports generator injections at the PV and slack buses.  Here is what the results tell us:

1. PV–Bus Generators (there are 3 in this case)  
   • Active power p setpoints are exactly 7.00 p.u. at each machine (i.e. the power‐flow solver holds each at its target).  
   • Their reactive injections end up as approximately  
     – Bus 1: q ≃ 2.2805 p.u.  
     – Bus 2: q ≃ 2.3238 p.u.  
     – Bus 3: q ≃ 1.0609 p.u.  

2. Slack Bus Generator (single machine)  
   • Supplies the system real‐power mismatch: p ≃ 7.2680 p.u.  
   • Supplies reactive mismatch:        q ≃ 1.0946 p.u.  

Interpretation for a power‐systems engineer:  
– All three PV‐type machines successfully held their 7 p.u. real‐power outputs; their reactive outputs vary to support system voltages.  
– The slack unit picks up the small net active deficit (~0.268 p.u.) and a bit of reactive imbalance (~1.095 p.u.), which is normal when PV machines are voltage‐controlled (their reactive is not preset)."
"Code: import andes
import numpy as np

ssa = andes.load(andes.get_case('5bus/pjm5bus.xlsx'))

ssa.PFlow.run()


bus_voltages = ssa.Bus.v.v
bus_ids = ssa.Bus.idx.v

index_max = int(np.nanargmax(bus_voltages))
index_min = int(np.nanargmin(bus_voltages))

print(f""Max Voltage: Bus {bus_ids[index_max]} = {bus_voltages[index_max]:.4f} p.u."")
print(f""Min Voltage: Bus {bus_ids[index_min]} = {bus_voltages[index_min]:.4f} p.u."")


# Print maximum and minimum bus voltage
                Code Output: STDOUT:
Max Voltage: Bus 0 = 1.0000 p.u.
Min Voltage: Bus 1 = 0.9918 p.u.","The script does the following:  
1. Loads the IEEE‐style 5‐bus PJM test case via ANDES.  
2. Runs a steady‐state AC power flow.  
3. Extracts the per‐unit voltage magnitudes at each bus.  
4. Identifies which bus has the highest voltage and which has the lowest.  

Results:  
• Bus 0 has the maximum voltage at 1.0000 p.u. (this is the slack/reference bus).  
• Bus 1 has the minimum voltage at 0.9918 p.u.  

Voltage spread across the entire 5-bus network is only 0.0082 p.u., well within typical ANSI/C84.1 limits. This indicates a very flat voltage profile under the given loading."
"Code: import andes
import numpy as np


# Voltage limits
V_MIN = 0.95
V_MAX = 1.05


ssa = andes.load(
    andes.get_case('kundur/kundur_full.xlsx')
)

ssa.PFlow.run()


bus_voltages = ssa.Bus.v.v
bus_ids = ssa.Bus.idx.v

# Max and min voltages
index_max = int(np.nanargmax(bus_voltages))
index_min = int(np.nanargmin(bus_voltages))

if bus_voltages[index_max] > V_MAX or bus_voltages[index_min] < V_MIN:
    print(""Voltage Violations Found"")

    # Check for violations
    print(f""Voltage Violations (Outside {V_MIN:.2f} – {V_MAX:.2f} p.u.):"")
    for bus_id, voltage in zip(bus_ids, bus_voltages):
        if voltage < V_MIN or voltage > V_MAX:
            print(f""Bus {bus_id}: {voltage:.4f} p.u."")
else:
    print(""No Voltage Violations Found"")


# Check for bus voltage violations
                Code Output: STDOUT:
No Voltage Violations Found","The provided script does the following:  
1. Loads the Kundur full test system via ANDES  
2. Runs a steady-state power-flow  
3. Extracts all bus voltages and their IDs  
4. Compares each voltage against the limits 0.95–1.05 p.u.  

Result:  
“No Voltage Violations Found”  

Interpretation for an EE: every bus in the Kundur case remained within the ±5% voltage band, indicating a healthy voltage profile under the given loading and network conditions. No buses dipped below 0.95 p.u. or rose above 1.05 p.u."
"Code: import andes
import numpy as np
import os

script_dir = os.getcwd()
case = os.path.join(script_dir, 'EI_33.xlsx')

ssa = andes.load(
    case
)

ssa.PFlow.run()

# Extract active and reactive power for all Slack generators
slack_p = ssa.Slack.p.v  # real power (P)
slack_q = ssa.Slack.q.v  # reactive power (Q)
slack_sn = ssa.Slack.Sn.v  # apparent power (Sn)
slack_ids = ssa.Slack.idx.v

# Compute apparent power S = sqrt(P^2 + Q^2)
s_apparent = np.sqrt(slack_p**2 + slack_q**2)

# Print results
for i, slack_generator in enumerate(slack_ids):
    print(f""Generator {slack_generator}: P = {slack_p[i]:.4f}, Q = {slack_q[i]:.4f}, |S| = {s_apparent[i]:.4f}, Sn = {slack_sn[i]:.4f}"")
    print(f""Generator {slack_generator}: Remaining Capacity = {slack_sn[i] - s_apparent[i]}"")


# Remaining generation capability for slack bus generators
# Units = MVA?
                Code Output: STDERR:
error: file ""/home/chen541/ANDES_Data/PowerFlow_Specific/EI_33.xlsx"" does not exist.
No valid case found.
Traceback (most recent call last):
  File ""/home/chen541/ANDES_Data/PowerFlow_Specific/code_examples/powerflow-ex28.py"", line 12, in <module>
    ssa.PFlow.run()
    ^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'PFlow'

ERROR conda.cli.main_run:execute(125): `conda run python code_examples/powerflow-ex28.py` failed. (See above for error)

Return Code: 1","The script you posted never actually makes it to the power‐flow or slack‐bus calculation because the network case file isn’t found. Here’s what happens step by step:

1. The code tries to load “EI_33.xlsx” from the current working directory via  
     ssa = andes.load(case)  
   Since that file doesn’t exist at the specified path, `andes.load()` returns None.

2. Immediately after, the script calls  
     ssa.PFlow.run()  
   but `ssa` is None, so you get the Python error  
     AttributeError: 'NoneType' object has no attribute 'PFlow'

3. No power‐flow is run, and no slack‐generator P, Q or apparent‐power values are computed.

To fix this, make sure:

 • The Excel case file “EI_33.xlsx” really lives in `os.getcwd()` (or adjust the path).  
 • After a successful `andes.load()` you should see a populated `ssa` object (not None).  
 • Then `ssa.PFlow.run()` will execute and you can extract slack‐bus P, Q, Sn and remaining capacity as intended."
"Code: import andes
import numpy as np


ssa = andes.load(
    andes.get_case('kundur/kundur_full.xlsx')
)

ssa.PFlow.run()


bus_angles = ssa.Bus.a.v
bus_ids = ssa.Bus.idx.v

# Max and min voltages
index_max = int(np.nanargmax(bus_angles))
index_min = int(np.nanargmin(bus_angles))
gap = bus_angles[index_max] - bus_angles[index_min]

print(f""Max Angle: Bus {bus_ids[index_max]} = {bus_angles[index_max]:.4f} Radians"")
print(f""Min Angle: Bus {bus_ids[index_min]} = {bus_angles[index_min]:.4f} Radians"")

print(f""Gap: {gap} Radians"")

if gap > (np.pi / 4):
    print(""Incorrect: Exceeds Upper Bound"")
else:
    print(""Correct: Within Upper Bound"")


# Check for bus angle difference, make sure it's 1/4 of pi (maximum), normal value is 30 degrees
                Code Output: STDOUT:
Max Angle: Bus 1 = 0.5703 Radians
Min Angle: Bus 8 = -0.0371 Radians
Gap: 0.6073804763492323 Radians
Correct: Within Upper Bound","The power‐flow on the full Kundur test case converged with the following key bus‐angle results:

 • Maximum voltage angle  
   – Bus 1: 0.5703 rad (≈32.7°)  
 • Minimum voltage angle  
   – Bus 8: –0.0371 rad (≈–2.1°)  
 • Overall angle spread (“gap”)  
   – Δθ = θmax – θmin = 0.6074 rad (≈34.8°)  

A simple check against the ¼·π rad (45°) stability limit shows Δθ < 0.7854 rad, so the inter‐bus angle separation remains within the prescribed upper bound."
"Code: import andes
import numpy as np

ssa = andes.load(andes.get_case('5bus/pjm5bus.xlsx'))

ssa.PFlow.run()


bus_voltages = ssa.Bus.v.v
bus_ids = ssa.Bus.idx.v

index_max = int(np.nanargmax(bus_voltages))
index_min = int(np.nanargmin(bus_voltages))

print(f""Max Voltage: Bus {bus_ids[index_max]} = {bus_voltages[index_max]:.4f} p.u."")
print(f""Min Voltage: Bus {bus_ids[index_min]} = {bus_voltages[index_min]:.4f} p.u."")
print(f""Difference: {bus_voltages[index_max] - bus_voltages[index_min]:.4f} p.u."")


# Maximum bus voltage difference
                Code Output: STDOUT:
Max Voltage: Bus 0 = 1.0000 p.u.
Min Voltage: Bus 1 = 0.9918 p.u.
Difference: 0.0082 p.u.","Here’s a concise engineering‐focused summary of what the script does and what the results tell us:

• Case and solver  
  – Loads the IEEE‐style 5‐bus “PJM” test case via ANDES.  
  – Runs a standard AC power‐flow (PFlow) to convergence.  

• Extraction of results  
  – Reads each bus’s voltage magnitude (in per‐unit) and its ID.  
  – Uses NumPy’s argmax/argmin to find the highest and lowest voltages.

• Key findings  
  – Maximum voltage: Bus 0 at 1.0000 p.u. (this is the slack/reference bus).  
  – Minimum voltage: Bus 1 at 0.9918 p.u.  
  – Peak‐to‐peak spread: 0.0082 p.u. (≈8.2 magnitude‐per‐unit, or ~0.82% of nominal).  

• Engineering implications  
  – Very flat voltage profile across the 5‐bus network.  
  – All bus voltages remain within typical ±5% (or even ±1%) regulation limits.  
  – Indicates good voltage regulation under the given load/generation pattern."
"Code: import andes
import numpy as np


# Voltage limits
V_MIN = 0.95
V_MAX = 1.05


ssa = andes.load(
    andes.get_case('kundur/kundur_full.xlsx')
)

# Add new load
ssa.add(model=""PQ"", param_dict=dict(bus=2, 
                                    idx=""PQ_484"", 
                                    p0=60/ssa.config.mva, 
                                    q0=100/ssa.config.mva
                                    ))

ssa.setup()
ssa.PFlow.run()

bus_voltages = ssa.Bus.v.v
bus_ids = ssa.Bus.idx.v

# Max and min voltages
index_max = int(np.nanargmax(bus_voltages))
index_min = int(np.nanargmin(bus_voltages))

if bus_voltages[index_max] > V_MAX or bus_voltages[index_min] < V_MIN:
    print(""Voltage Violations Found"")

    # Check for violations
    print(f""Voltage Violations (Outside {V_MIN:.2f} – {V_MAX:.2f} p.u.):"")
    for bus_id, voltage in zip(bus_ids, bus_voltages):
        if voltage < V_MIN or voltage > V_MAX:
            print(f""Bus {bus_id}: {voltage:.4f} p.u."")
else:
    print(""No Voltage Violations Found"")


# Add new load to specific bus or new generation, or general operations of the base case (if a load goes down, are there any voltage violations)
                Code Output: STDERR:
Traceback (most recent call last):
  File ""/home/chen541/ANDES_Data/PowerFlow_Specific/code_examples/powerflow-ex29.py"", line 15, in <module>
    ssa.add(model=""PQ"", param_dict=dict(bus=2, 
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/chen541/miniconda3/envs/power-simulation-env/lib/python3.12/site-packages/andes/system.py"", line 547, in add
    raise NotImplementedError(""Adding devices are not allowed after setup."")
NotImplementedError: Adding devices are not allowed after setup.

ERROR conda.cli.main_run:execute(125): `conda run python code_examples/powerflow-ex29.py` failed. (See above for error)

Return Code: 1","The traceback shows that the script never actually reached the power‐flow or the voltage‐check logic because it failed on the call to  
    ssa.add(model=""PQ"", …)  
with  
    NotImplementedError: “Adding devices are not allowed after setup.”  

What happened:  
1. andes.load(…) by default performs an internal “setup” of the network (builds buses, branches, devices, etc.).  
2. As soon as the system is in that “setup” state, andes prohibits any further topology changes—hence your ssa.add() call is rejected.  
3. Because of that error the script aborts, so no power‐flow is run and no bus‐voltage data are produced.

Electrical-engineering takeaways:  
• You intended to place a new PQ load of 60 MW + 100 MVAr on bus 2 (p0=60/MVA, q0=100/MVA).  
• After loading the Kundur network you must add any new loads (or generators) before the final setup() call.  
• Once setup() succeeds you can run PFlow and then pull ssa.Bus.v.v to get per-unit voltages at every bus and compare against your ±5% limits.  

How to fix:  

Option 1 – Disable automatic setup:  
```python
ssa = andes.load(
    andes.get_case('kundur/kundur_full.xlsx'),
    setup=False         # ← do not build yet
)
ssa.add(model=""PQ"", param_dict={…})
ssa.setup()            # now build with your new load included
ssa.PFlow.run()
…  # voltage‐check code
```

Option 2 – Manual workflow:  
```python
import andes
# 1) create empty system
ssa = andes.System()
# 2) load raw data (no setup)
ssa.load_case('kundur/kundur_full.xlsx', setup=False)
# 3) add new devices
ssa.add(model=""PQ"", param_dict={…})
# 4) finalize and run
ssa.setup()
ssa.PFlow.run()
…  # voltage‐check code
```

Once the power‐flow runs, your existing logic will correctly scan ssa.Bus.v.v against 0.95–1.05 p.u. and print any buses outside that range."
"Code: import andes

ssa = andes.load(
    andes.get_case('GBnetwork/GBnetwork.xlsx'),
    setup=False,     # If setup=False, need to call ss.setup() before running the simulation
    no_output=True, 
    default_config=False
)

# Add new load
ssa.add(model=""PQ"", param_dict=dict(bus=2, 
                                    idx=""PQ_484"", 
                                    p0=60/ssa.config.mva, 
                                    q0=100/ssa.config.mva
                                    ))

ssa.setup()
ssa.PFlow.run()

print(""PQ Bus Active Power"", ssa.PQ.p0.v)
print(""PQ Bus Reactive Power"", ssa.PQ.q0.v)
print(""PQ Table"", ssa.PQ.as_df())


# Load the IEEE 39-bus case, add a new load with 60 MW p0 and 100 MW q0, then set up and run a power-flow simulation.
                Code Output: STDOUT:
PQ Bus Active Power [ 7.7900e-02  1.5980e-01  1.5830e-01  1.7680e-01  4.5000e-02  1.2564e+00
  9.4000e-01  2.1640e+00  4.4800e-02  3.4120e-01  2.1510e+00  2.3346e+00
  3.8667e+00  5.8400e-02  2.6783e+00  1.7040e-01  1.7040e-01  1.4610e-01
  9.9800e-02  1.2660e-01  1.2660e-01  1.4610e-01  9.7000e-03  7.5400e-02
  0.0000e+00  8.5000e-03  5.4900e-02  1.3640e-01  1.3640e-01  7.4020e-01
  2.6867e+00  2.9240e-01  8.5000e-02  1.0783e+00  9.7780e-01  7.8960e-01
  1.2533e+00  1.9082e+00  3.2870e+00  1.3927e+00  1.6426e+00  2.1095e+00
  2.6324e+00  2.1728e+00  2.1728e+00  1.2466e+00  1.3570e-01  8.1420e-01
  6.0860e-01 -4.0950e-01  7.7810e-01  8.5510e-01  2.1767e+00  2.1767e+00
  1.6362e+00  1.6362e+00  3.2335e+00  2.7270e+00  1.2564e+00  2.6004e+00
  3.4467e+00  1.6344e+00  5.9280e-01  3.1478e+00  3.1273e+00  2.5001e+00
  2.2030e+00  3.5646e+00  3.4770e+00  3.8461e+00  1.1005e+00  2.6705e+00
  1.2320e+00  1.2320e+00  2.0196e+00  2.5314e+00  1.3724e+00  2.4491e+00
 -5.4800e-02  2.6790e+00  1.7954e+00  1.7390e+00  2.5004e+00  2.1056e+00
  2.1056e+00  2.5850e+00  4.6437e+00  1.1327e+00  2.6790e-01  2.5066e+00
  3.2713e+00  2.1479e+00  2.1479e+00  2.6208e+00  2.6208e+00  4.5522e+00
  5.3771e+00  5.0438e+00  4.7195e+00  6.5604e+00  2.7572e+00  3.8071e+00
  4.8960e+00  1.7482e+00  1.7151e+00  3.9328e+00  2.0779e+00  4.4611e+00
  5.0800e+00  1.6460e+00  2.7222e+00  1.1473e+00  1.0528e+00  3.9980e+00
  1.5232e+00  1.6742e+00  1.1492e+00  9.4470e-01  3.3942e+00  2.0813e+00
  1.0199e+00  2.5078e+00  8.3887e+00  2.2881e+00  2.0394e+00  1.4633e+00
  2.1914e+00  2.1914e+00  4.3650e-01  4.3650e-01  1.3472e+00  1.4170e+00
  1.2532e+00  1.2532e+00  1.3107e+00  1.3107e+00  1.7097e+00  1.4699e+00
  3.0947e+00  3.0947e+00  3.7810e-01  3.8920e-01  3.8920e-01  3.5550e-01
  1.5008e+00  1.5008e+00  2.9253e+00  1.9742e+00  1.7344e+00  6.0870e-01
  2.5064e+00  1.5740e-01  1.5740e-01  2.6881e+00  2.7173e+00  8.4860e-01
  8.4860e-01  1.8872e+00  2.1807e+00  9.2730e-01  9.2730e-01  2.0647e+00
  6.7200e-01  6.7200e-01  8.4860e-01  8.4860e-01  8.4860e-01  7.8780e-01
  7.8780e-01  8.2430e-01  7.8540e-01  2.4510e+00  1.9198e+00  1.0479e+00
  9.2730e-01  3.6940e-01  2.0786e+00  2.0786e+00  1.0708e+00  1.0708e+00
  3.5060e-01  2.9315e+00  3.4258e+00  2.1453e+00  3.6625e+00  1.6821e+00
  1.6821e+00  6.7397e+00  7.2412e+00  5.6000e-01  2.1875e+00  1.3956e+00
  1.4289e+00  2.7465e+00  4.2853e+00  3.2529e+00  2.9927e+00  3.5132e+00
  2.0745e+00  2.8546e+00  1.8310e+00  1.2501e+00  1.2501e+00  1.6654e+00
  9.6420e-01  3.3126e+00  2.7705e+00  2.2693e+00  3.0465e+00  1.8855e+00
  1.8407e+00  9.7010e-01  9.7010e-01  1.4398e+00  3.8665e+00  2.2303e+00
  1.8922e+00  1.6574e+00  9.4910e-01  4.7051e+00  1.0139e+00  7.7920e-01
  1.0152e+00  5.9220e-01  1.0869e+00  8.1520e-01  9.1180e-01  6.0160e-01
  6.4880e-01  4.8880e-01  3.7600e-02  4.7940e-01  9.1180e-01  5.0260e-01
  2.3970e-01  6.2980e-01  1.0713e+00  6.4770e-01  6.4770e-01  2.2560e-01
  9.8700e-01  1.2554e+00  1.8395e+00  1.7491e+00  9.0500e-02  9.1400e-02
  1.4633e+00  1.7456e+00  6.1571e+00  2.9253e+00  2.9253e+00  5.4830e-01
  1.9625e+00  2.0927e+00  1.9280e-01  3.5800e-02  3.1000e-03  2.2215e+00
  2.2382e+00  2.2382e+00  2.3760e+00  2.3760e+00  9.0870e-01  9.0870e-01
  2.0869e+00  3.0080e-01  2.7144e+00  1.8110e+00  3.2737e+00  3.3600e-01
  3.3600e-01  2.2488e+00  3.0294e+00  3.7026e+00  3.7550e-01  2.3486e+00
  3.2737e+00  1.4899e+00  1.4899e+00  2.6798e+00  2.6798e+00  2.1086e+00
  3.0533e+00  3.5898e+00  4.0148e+00  1.4736e+00  2.1807e+00  1.8872e+00
  1.4699e+00  1.3550e+00  1.3550e+00  1.6448e+00  1.6448e+00  1.2541e+00
  7.3690e-01  7.3412e+00  6.3034e+00  1.5304e+00  8.6360e-01  8.6360e-01
  2.9700e+00  1.9817e+00  3.0000e+00  3.3970e-01  1.4046e+00  3.2980e-01
  2.7020e-01  4.7780e-01  4.5600e-01  2.7020e-01  2.3540e-01  1.0130e-01
  6.8050e-01  6.1290e-01  4.5400e-01  3.5170e-01  6.2190e-01  5.9700e-01
 -6.6600e-02  5.9900e-01  8.7520e-01  7.3710e-01  4.1620e-01  1.0023e+00
  1.0330e-01  1.6790e-01 -6.8500e-02  9.1990e-01  6.4670e-01  3.5860e-01
  3.5860e-01  7.0930e-01 -1.9670e-01  3.3680e-01  3.0400e-01  9.1690e-01
 -1.1720e-01  3.6850e-01  9.4570e-01  6.8740e-01  1.9870e-01  8.0360e-01
  9.0300e-01  1.4600e-01  2.8310e-01  5.8710e-01  1.0530e+00  5.4930e-01
  3.2280e-01  2.4640e-01  6.4070e-01  7.3710e-01  4.0330e-01  3.4770e-01
  2.9300e-01  3.5760e-01  2.3940e-01  3.9730e-01  4.6090e-01  6.4600e-02
  4.7780e-01  3.8640e-01  4.5500e-01  4.2520e-01  8.2250e-01  7.1520e-01
  6.4570e-01  4.1130e-01  4.7680e-01  6.7550e-01  5.3600e-02  3.9930e-01
  2.7520e-01  5.1850e-01  5.4140e-01  4.2220e-01  1.1670e-01  1.1670e-01
  4.2020e-01  7.7680e-01  7.9670e-01  2.0860e-01  7.0830e-01  2.4540e-01
  1.1030e-01  4.5990e-01  6.6370e-01  1.2720e-01  5.6030e-01  4.8080e-01
  1.2720e-01  3.3970e-01 -3.9700e-02 -3.9700e-02  3.3580e-01  7.3010e-01
 -2.0000e-01 -1.1120e-01  1.3400e-02 -1.0000e-01 -2.0000e-01 -3.6070e-01
 -2.0300e-01 -4.0700e-01 -3.8000e-01 -9.7200e-02 -2.3000e-01 -7.5000e-02
 -2.5000e-01 -2.0000e-01 -2.0000e-01 -6.0000e-02 -2.3500e-01 -2.3500e-01
 -1.7000e-01 -1.7000e-01  6.6320e-01 -1.8000e-01  1.6700e-02 -3.9000e-02
 -3.9000e-02 -7.5000e-02 -7.5000e-02 -7.5000e-02  2.6870e-01  3.0630e-01
  4.0200e-01  3.2270e-01  1.7630e-01  3.0200e-02  2.7520e-01  1.3760e-01
  2.5000e-01  4.3440e-01  7.2480e-01  2.2000e-03  5.6320e-01  2.0590e-01
  6.2780e-01  1.7110e-01  1.4150e-01  2.7410e-01  3.8140e-01  6.1300e-02
  1.8980e-01  2.5900e-02  4.1760e-01  3.6620e-01  2.2190e-01  7.9400e-02
  8.5600e-02  5.0340e-01  4.7100e-02  3.0490e-01  4.6600e-01  3.2120e-01
  6.4700e-02  3.6310e-01  5.6240e-01 -1.8000e-03  5.4000e-03  2.3370e-01
  2.2900e-01  3.4060e-01  1.1870e-01  1.1870e-01  3.7800e-02 -6.1000e-03
  3.4950e-01  3.0880e-01  3.1720e-01  6.9900e-02  2.2210e-01  5.3070e-01
  4.0490e-01 -2.8400e-02  1.7390e-01 -3.4000e-01  1.0080e-01  4.7230e-01
  4.4340e-01  3.3130e-01  9.7700e-02  6.0000e-01]
PQ Bus Reactive Power [ 2.1520e-01  1.1470e-01  1.0930e-01  0.0000e+00  3.3700e-02  7.1000e-01
  2.7450e-01  8.2940e-01  2.8200e-02  1.2370e-01  1.0069e+00  6.9250e-01
  1.2203e+00  3.0200e-02  9.6230e-01  0.0000e+00  0.0000e+00  0.0000e+00
  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  1.0000e-03  1.0600e-02
  1.1270e+01  0.0000e+00  4.1400e-02  1.1490e-01  1.1490e-01  1.0520e-01
  0.0000e+00  2.1930e-01  6.4000e-02  3.1440e-01  2.4490e-01  2.3030e-01
  4.9540e-01  6.2700e-01  1.3129e+00  2.8240e-01  4.7920e-01  9.6130e-01
  7.1580e-01  6.3400e-01  6.3400e-01  7.0610e-01  1.0100e-01  3.1980e-01
  2.8510e-01  3.9500e-01  2.3400e-01  2.3160e-01  3.1360e-01  3.1360e-01
  4.6750e-01  4.6750e-01  5.0640e-01  3.8860e-01  7.1000e-01  6.7300e-01
  8.7650e-01  5.5720e-01  0.0000e+00  8.2880e-01  1.0937e+00  8.4440e-01
  8.2590e-01  1.1541e+00  1.0353e+00  1.3810e+00  4.2170e-01  9.4370e-01
  4.7140e-01  4.7140e-01  5.0630e-01  8.3160e-01  5.4240e-01  6.1410e-01
 -1.6400e-02  9.7200e-01  4.5030e-01  5.7150e-01  8.2160e-01  6.9190e-01
  7.6420e-01  7.5390e-01  1.2380e+00  5.4050e-01  1.2220e-01  9.9080e-01
  1.4909e+00  5.8190e-01  6.2420e-01  7.7460e-01  7.7460e-01  1.5330e+00
  1.3216e+00  1.5805e+00  1.4793e+00  1.9810e+00  8.1420e-01  1.0353e+00
  1.8982e+00  8.1520e-01  1.1522e+00  2.2235e+00  4.6850e-01  8.0840e-01
  1.7375e+00  5.5810e-01  6.0580e-01  3.4280e-01  3.1460e-01  6.4080e-01
  2.1720e-01  3.1070e-01  2.8240e-01  1.3440e-01  1.0704e+00  6.0190e-01
  3.6520e-01  7.6060e-01  2.7574e+00  9.0380e-01  1.0449e+00  5.7780e-01
  9.2870e-01  9.2870e-01  1.4320e-01  1.4320e-01  4.4310e-01  4.6360e-01
  4.0760e-01  4.0760e-01  6.7160e-01  6.7160e-01  8.7600e-01  7.6500e-01
  1.0168e+00  1.0168e+00  1.3120e-01  1.2820e-01  1.2820e-01  1.1690e-01
  4.9380e-01  4.9380e-01  7.6100e-01  6.4910e-01  5.6980e-01  2.2090e-01
  8.1520e-01  1.3490e-01  1.3490e-01  1.3177e+00  1.3323e+00  2.4760e-01
  2.4760e-01  1.1318e+00  1.0694e+00  4.5460e-01  4.5460e-01  1.0119e+00
  3.2920e-01  3.2920e-01  2.4760e-01  2.4760e-01  2.4760e-01  3.8600e-01
  3.8600e-01  2.5130e-01  2.2890e-01  1.2013e+00  9.4130e-01  5.1340e-01
  4.5460e-01  1.8090e-01  6.0620e-01  6.0620e-01  3.1230e-01  3.1230e-01
  1.7240e-01  1.4375e+00  1.1258e+00  7.9590e-01  1.0680e+00  5.2280e-01
  5.2280e-01  2.0930e+00  2.8624e+00  1.4020e-01  5.4350e-01  2.9510e-01
  3.0290e-01  6.7400e-01  1.0626e+00  8.0250e-01  6.1460e-01  7.2170e-01
  2.9220e-01  9.1940e-01  5.1230e-01  2.3280e-01  2.3280e-01  4.7630e-01
  4.7720e-01  1.1921e+00  9.5450e-01  3.2040e-01  9.8080e-01  7.4510e-01
  8.5610e-01  3.0100e-01  3.0100e-01  5.2280e-01  1.5466e+00  7.8400e-01
  2.6980e-01  5.0940e-01  2.7660e-01  1.7667e+00  2.9610e-01  2.6980e-01
  6.9000e-01  1.2030e-01  3.3210e-01  2.6780e-01  3.8820e-01  8.5500e-02
  1.8920e-01  4.1830e-01  2.6300e-02  0.0000e+00  1.8520e-01  1.4620e-01
  1.3910e-01  6.4300e-01  2.1720e-01  2.9510e-01  2.9510e-01  1.2220e-01
  2.4720e-01  7.4510e-01  9.0170e-01  8.5720e-01  1.2800e-02  1.2800e-02
  5.7780e-01  0.0000e+00  2.8050e+00  7.6100e-01  7.6100e-01  4.8340e-01
  8.9410e-01  5.2460e-01  5.5700e-02  2.5300e-02  1.9000e-03  6.6420e-01
  6.5250e-01  6.5250e-01  6.9270e-01  6.9270e-01  2.9800e-01  2.9800e-01
  5.7270e-01  4.3200e-02  1.0723e+00  4.9180e-01  9.5450e-01  4.7700e-02
  4.7700e-02  3.2720e-01  8.8340e-01  1.0801e+00  1.2370e-01  4.7700e-01
  9.5450e-01  3.0270e-01  3.0270e-01  7.8210e-01  7.8210e-01  9.0480e-01
  1.2048e+00  1.4184e+00  1.5871e+00  5.8240e-01  1.0694e+00  1.1318e+00
  7.6500e-01  5.1870e-01  5.1870e-01  4.7970e-01  4.7970e-01  3.8950e-01
  2.3400e-01  3.3442e+00  1.9790e+00  7.6970e-01  3.0520e-01  3.0520e-01
  0.0000e+00  6.7580e-01  1.5300e+00  9.7400e-02  3.1490e-01  1.4900e-01
  3.7700e-02  1.3910e-01  1.2910e-01  5.6600e-02 -6.9500e-02  3.3800e-02
  1.6690e-01  1.6190e-01 -1.0230e-01  7.2500e-02  1.5300e-01  1.6690e-01
  0.0000e+00  1.4700e-01  2.4740e-01  1.4800e-01  8.3400e-02  2.5130e-01
  6.1600e-02  3.3800e-02 -9.9000e-03  1.8280e-01  1.5700e-01  9.1400e-02
  9.4400e-02  1.4300e-01  0.0000e+00  9.6400e-02  7.5500e-02  1.9370e-01
  0.0000e+00  7.3500e-02  3.3970e-01  1.9670e-01  5.5600e-02  1.9970e-01
  2.2650e-01  4.0700e-02  7.0500e-02  1.6990e-01  1.6890e-01  1.1420e-01
  4.5700e-02  9.4400e-02  1.3110e-01  1.4700e-01  1.2620e-01  7.6500e-02
  5.8600e-02  8.7400e-02  7.2500e-02  9.7400e-02  1.3410e-01  2.7800e-02
  1.1820e-01  9.4400e-02  9.0400e-02  1.2020e-01  2.0660e-01  2.3540e-01
  1.6690e-01  1.1620e-01  1.1720e-01  2.1260e-01  1.9900e-02  1.0030e-01
  7.1500e-02  1.6890e-01  1.3110e-01  1.2220e-01  0.0000e+00  0.0000e+00
  1.0230e-01  2.5530e-01  1.5890e-01  4.1700e-02  1.4110e-01  6.0600e-02
  2.7800e-02  1.1620e-01  1.7580e-01  0.0000e+00  8.5130e-01 -2.4040e-01
  3.2800e-02  8.3400e-02  0.0000e+00  0.0000e+00  9.4400e-02  1.9770e-01
  0.0000e+00  0.0000e+00  2.0000e-03  0.0000e+00  0.0000e+00  7.9000e-03
  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00
  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00
  0.0000e+00  0.0000e+00  1.3280e-01  0.0000e+00  3.0000e-03  0.0000e+00
  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  5.3500e-02 -6.0500e-02
  1.0410e-01  7.9300e-02  0.0000e+00  4.0000e-03  7.3400e-02  0.0000e+00
 -3.5700e-02  1.0610e-01  2.0520e-01  2.0000e-03  2.2010e-01 -5.9500e-02
  1.6750e-01 -3.4700e-02  1.9800e-02  5.4500e-02  0.0000e+00  1.4900e-02
  2.6800e-02  7.6300e-02  1.0310e-01  7.3400e-02  4.4600e-02  1.0900e-02
  1.6900e-02  1.0110e-01  6.9000e-03  6.1500e-02  1.4870e-01  4.5600e-02
  1.2900e-02  1.0610e-01  1.3980e-01 -2.0000e-03  2.0000e-03  4.7600e-02
  7.4400e-02  4.8600e-02  3.7700e-02  3.7700e-02  1.0900e-02 -5.9000e-03
  8.8200e-02  6.1500e-02  8.1300e-02  9.9000e-03  5.5500e-02  1.0710e-01
  1.1500e-01 -8.9000e-03  3.4700e-02  0.0000e+00  3.0700e-02  9.5200e-02
  1.1000e-01  0.0000e+00  1.9800e-02  1.0000e+00]
PQ Table         idx    u     name   bus     Vn      p0      q0  vmax  vmin owner
uid                                                                     
0      PQ_1  1.0    PQ 14    14  400.0  0.0779  0.2152   1.2   0.8  None
1      PQ_2  1.0    PQ 50    50  400.0  0.1598  0.1147   1.2   0.8  None
2      PQ_3  1.0    PQ 74    74  400.0  0.1583  0.1093   1.2   0.8  None
3      PQ_4  1.0   PQ 133   133  400.0  0.1768  0.0000   1.2   0.8  None
4      PQ_5  1.0   PQ 141   141  400.0  0.0450  0.0337   1.2   0.8  None
..      ...  ...      ...   ...    ...     ...     ...   ...   ...   ...
479  PQ_480  1.0  PQ 2218  2218   33.0  0.4723  0.0952   1.2   0.8  None
480  PQ_481  1.0  PQ 2219  2219   33.0  0.4434  0.1100   1.2   0.8  None
481  PQ_482  1.0  PQ 2220  2220   33.0  0.3313  0.0000   1.2   0.8  None
482  PQ_483  1.0  PQ 2223  2223   11.0  0.0977  0.0198   1.2   0.8  None
483  PQ_484  1.0   PQ_484     2  110.0  0.6000  1.0000   1.2   0.8  None

[484 rows x 10 columns]","The script does three things:  
1) it loads the “GBnetwork” Excel‐based case into an Andes steady‐state analysis object (ssa),  
2) it appends a new constant‐power (PQ) load of 60 MW + j100 MVAr on bus 2,  
3) it runs an AC power‐flow and then prints out the per‐unit P and Q at every PQ bus plus the full PQ‐load table.  

Key points for an EE engineer:  
– Base MVA (ssa.config.mva) is 100 MVA, so the new load shows up as P0=60/100=0.6 p.u., Q0=100/100=1.0 p.u.  
– There are 484 PQ entries in total: 483 original loads plus the newly added PQ_484 on bus 2.  
– The printed P‐vector (ssa.PQ.p0.v) and Q‐vector (ssa.PQ.q0.v) each have length 484. The final element in each is 0.6 p.u. (active) and 1.0 p.u. (reactive), corresponding to the new load.  
– Across all PQ buses you see loads ranging roughly from near zero up to ~8.4 p.u. of P and up to ~11.3 p.u. of Q (per‐unit). A few very small negative Q’s indicate injected reactive power at some buses (e.g. passive shunts or generation).  
– The PQ DataFrame confirms the new entry:  

   idx    name   bus   Vn    p0    q0  vmax  vmin  
   …                                 
   483  PQ_484     2  110.0  0.60  1.00  1.2   0.8  

where “bus” is the bus number (2), “Vn” the nominal voltage in kV, p0/q0 the per‐unit loads, and [vmin,vmax] the voltage limits.  

In short, the code successfully injects a 60 MW/100 MVAr load at bus 2, solves the power‐flow, and returns all PQ setpoints both as raw per‐unit arrays and as a tabular listing of all 484 PQ loads."
